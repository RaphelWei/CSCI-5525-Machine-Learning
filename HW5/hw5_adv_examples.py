# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J1FUhgokWdAFQNuEz9CefcmqgfzZj7gx
"""

from torchvision.models import resnet50
from torchvision import transforms
import torch
import torch.nn as nn
import matplotlib.pyplot as plt
from pandas import read_json
import numpy as np

# Get ResNet
resnet = resnet50(pretrained = True)
resnet.eval() # test mode

# Prepare our image
label = read_json('imagenet_class_index.json') # get true labels
original_img = plt.imread("Elephant2.jpg") # shape (1553, 2293, 3)
# process the image, reshape it.
preprocess = transforms.Compose([transforms.ToPILImage(),
                                 transforms.Resize(224),
                                transforms.ToTensor(),
                                 ])
img = preprocess(original_img)[None, :, :, :] # torch.size([1, 3, 224, 330])
# Normalize the image
normalize = transforms.Normalize(mean=[0.485, 0.456, 0.406],
                                 std=[0.229, 0.224, 0.225]
                                 )
# predict with ResNet
pred = resnet(img) 
# Get the class name 
_, index = torch.max(pred, 1) # index = tensor([101])
class_name = label[index.numpy()[0]][1]
print("Class Name: ", class_name)

# Hyperparameters Initialization
epoch_num = 20
lr = 0.01

class AdversarialNet(nn.Module):
    """ 
    This is a class of our adversarial examples
    We will use this class to generate images fool resnet
    However, human will find generated images are similar with original one
    """

    def __init__(self):
        super(AdversarialNet, self).__init__()
        """
        A neural network composed of fc-leakyReLU-fc-Tanh
        I tried to use more hidden layers, however, there are too many parameters
        The memory is nearly crashed.
        """
        self.layer = nn.Sequential(nn.Linear(1280, 5120),
                                             nn.LeakyReLU(0.2),
                                             nn.Linear(5120, 3*224*330), # Size of our image is ()
                                             nn.Tanh()
                                   )      
    def forward(self, img):
        """
        Function of forward propagation
        We generate some random noise to add on our image
        However, we should clamp the noise so that we would 
        not change the image too far.
        """
        noise = torch.randn(1, 1280) * 0.001 # gaussian random noise
        z = self.layer(noise).view(img.size())
        z = z.clamp(-0.1, 0.1) # clamp noise within some interval
        noised_img = img + z
        return noised_img

adv_a = AdversarialNet() # an adversial model we will train for problem A
adv_a_optim = torch.optim.SGD(adv_a.parameters(), lr=lr)
adv_b = AdversarialNet() # an adversial model we will train for problem B
adv_b_optim = torch.optim.SGD(adv_b.parameters(), lr=lr)
def criterion_a(x):
    """
    loss function for problem a, we use negative value of cross entropy loss
    because we don't want resnet classfy correctly.
    """
    loss = -10 * nn.CrossEntropyLoss()(resnet(x), torch.LongTensor([101]))
    return  loss

def criterion_b(x):
    """
    in this loss function, we want the adversial net to classfy image
    as "bullet_train" rather than "tusker"
    Hence, the loss function should show a penalty for classifying as "tusker"
    Thus, we simply multiply "tusker" loss a negative coefficient, 
    on the contrary, multiply "train" loss a positive coefficient.
    """
    # index of "bullet_train" is 466
    loss1 = nn.CrossEntropyLoss()(resnet(x), torch.LongTensor([101])) # loss for classfying as "tusker"
    loss2 = nn.CrossEntropyLoss()(resnet(x), torch.LongTensor([466])) # loss for classfying as "bullet_train"
    loss = loss1 * (-10) + loss2 * 10
    return loss

def train_adversarial(img, model, optimizer, criterion):
    """
    This is a function to train our adversarial models
    @params
    img - input image
    model - model we would like to train
    optimizer - optimizer of given model
    criterion - loss function
    """
    for epoch in range(epoch_num):
        # generated noised image using 
        noised_img = model(img)
        loss = criterion(noised_img)

        # Backpropagation, update weights
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
        print('Epoch [{}/{}], Loss: {:.6f}'.format(epoch+1, epoch_num, loss.item()))
    return noised_img
#####################################################################################
###																					#
###                        PART             A                                       #
###																					#
###																					#
#####################################################################################
noised_img = train_adversarial(img, adv_a, adv_a_optim, criterion_a)
# reshape the noised image, (1,3,224,330) --> (1,224,330,3)
img_a = np.transpose(noised_img.detach(), (0, 2, 3, 1))
# plot noised image
plt.imshow(img_a[0])
plt.savefig("p7_img_a.eps")
plt.show()
# Prediction
pred_a = resnet(noised_img)
_, index_a = torch.max(pred_a, 1)
class_name = label[index_a.numpy()[0]][1]
print("Class Name: ", class_name)
#####################################################################################
###                                                                                 #
###                        PART             B                                       #
###                                                                                 #
###                                                                                 #
#####################################################################################
noised_img = train_adversarial(img, adv_b, adv_b_optim, criterion_b)
# reshape the noised image, (1,3,224,330) --> (1,224,330,3)
img_b = np.transpose(noised_img.detach(), (0, 2, 3, 1))
# plot noised image
plt.imshow(img_b[0])
plt.savefig("p7_img_b.eps")
plt.show()
# Prediction
pred_b = resnet(noised_img)
_, index_b = torch.max(pred_b, 1)
class_name = label[index_b.numpy()[0]][1]
print("Class Name: ", class_name)